---
title: "Hausaufgabe: Evo-Devo-Mausdaten"
subtitle: "Musterlösung"
author: "mariia"
format: 
  html:
    embed-resources: TRUE
editor: visual
---

## Präprozessierung

Laden Sie die Mausdaten und normalisieren Sie sie (wandeln sie in cpm-Werte um).

```{r}
library(tidyverse)
read_tsv("evodevo_mouse_counts.tsv") -> mouse_counts
mouse_counts[1:5,1:5]
```

```{r}
tibble( sample = colnames(mouse_counts) [-1] ) %>%
  separate( sample, c( "organ", "timepoint", "replicate" ), sep = "_", remove = FALSE) %>%
  mutate( timepoint = fct_inorder(timepoint) ) -> sample_table
```

```{r}
mouse_counts %>%
  pivot_longer( -gene_id, names_to = "sample", values_to = "count" ) %>%
  group_by( sample ) %>%
  mutate( cpm = count / sum(count) * 1e6 ) -> cpm_long

cpm_long %>% head()
```

## Aufgabe 1: Vergleich zweier Proben

###1a

Erstellen Sie dazu zunächst ein Streudiagramm, dass die Expression in den `Proben Liver_P3_1` und `Liver_P63_1` vergleicht, d.h., Ihr Diagramm sollte jedes Gen durch einen Punkt darstellen, mit Expressionsstärke (in CPM) in einer Probe als x-Koordinate und in der anderen Probe als y-Koordinate. Die Achsen sollten logarithmisch sein.

Um sicher zu stellen, dass Sie keine Gene verlieren, für die der Read-Count 0 beträgt (Warum ist das ein Problem?), zählen Sie zu allen Werten 0.1 hinzu. Wie ändert sich der Plot?

```{r}
cpm_long %>%
  select(-count) %>%
  pivot_wider(names_from = sample, values_from = cpm) -> cpm_wide

head(cpm_wide, 5)
```

```{r}
cpm_wide %>%
  ggplot() +
  geom_point(
    aes( x = (Liver_P63_1 + .1), y = (Liver_P3_1 + .1) ), 
    alpha = .3, cex = .2
  ) +
  geom_abline( slope = 1, col = "orange" ) +
  scale_x_log10() + scale_y_log10() +
  xlab( "cpm Liver_P63_1" )  + ylab( "cpm Liver_P3_1" )
```

Für Gene mit niedriger Expressionsstärke (geringe Read-Zahlen) ist der CPM-Wert häufig gleich null. Der `log10` von null ist in R `-Inf` und kann daher nicht sinnvoll dargestellt oder weiterverarbeitet werden. 

Um dieses Problem zu vermeiden und weiterhin mit reellen Zahlen zu arbeiten, wird ein kleiner positiver Wert (z. B. 0,1) zu den CPM-Werten addiert (*Pseudocount*). Dies hat keinen relevanten Einfluss auf stark exprimierte Gene, aber die Gene mit sehr niedriger oder null Expression erhalten dadurch einen definierten Logarithmuswert (`log10(0.1) = -1`) und können somit geplottet und analysiert werden.

### 1b

Berechnen Sie das Verhältnis der Expressionsstärken in `Liver_P63_1` und `Liver_P3_1`, d.h., teilen sie die CPM-Werte in den beiden Proben durch einander. Addieren Sie vorher wieder 0.1 zu allen Werten, damit Sie nicht durch 0 teilen. Berechnen Sie ebenso den Mittelwert zwischen den Expressionsstärken in den beiden Proben. Plotten Sie dann die Verhältnisse (y-Achse) gegen die Mittelwerte (x-Achse).

Warum sollten die Achsen auch hier wieder logarithmisch sein?

Anstatt ggplot aufzutragen, die Achsen logarithmisch zu skalieren, nehmen Sie die Logarithmen selbst, indem Sie z.B. `lcpm = log10( cpm + 0.1 )` rechnen.

```{r}
cpm_wide %>%
  ggplot() +
  geom_point(
    aes( 
      x = log10( ( (Liver_P63_1 + .1) + (Liver_P3_1 + .1) ) / 2 ), 
      y = log10( (Liver_P63_1 + .1) / (Liver_P3_1 + .1) ) 
      ), 
    alpha = .3, cex = .2
  ) +
  xlab( "Mittelwerte" )  + ylab( "Verhältnisse" )
```

Die Achsen sollten auch hier logarithmisch sein, weil sowohl die Expressionsstärken als auch ihre Verhältnisse mehrere Größenordnungen umfassen können. Beachten Sie, dass sich die Skalierung unterscheidet, je nachdem ob in ggplot eine logarithmische Achse verwendet wird oder ob direkt die logarithmierten Werte geplottet werden.

### 1c

Wie ändert sich der Plot, wenn Sie nun die Mittelwerte so berechnen, dass Sie erst die Logarithmen nehmen und dann erst zwischen den beiden Werten mitteln?

Betrachten Sie auch die Verhältnisse nochmals. Vergleichen Sie folgende Ausdrücke:`log10( (cpmA + 0.1) / (cpmB + 0.1) )` und `log10(cpmA + 0.1) - log10(cpmB + 0.1)` 

Im ersten Ausdruck teilen wir die cpm-Werte der beiden Proben durcheinander und nehmen dann den Logarithmus der Bruchs. Um zweiten Ausdruck ziehen wir die logarithmierten cpm-Werte voneinander ab. In beiden Fällen addieren stets als erstes wir einen kleinen Wert (`+ 0.1`), um Nullen zu vermeiden.

Welcher eignet sich besser, um die logarithmierten Expressionsverhältnisse (y-Achse unseres Plots) darzustellen?

```{r}
cpm_wide %>%
  ggplot() +
  geom_point(
    aes( 
      x = ( log10( (Liver_P63_1 + .1) ) + log10( (Liver_P3_1 + .1) ) ) / 2 ,
      y = log10(Liver_P63_1 + .1) - log10(Liver_P3_1 + .1)  # = log10( (Liver_P63_1 + 0.1) / (Liver_P6_1 + 0.1) )
      ), 
    alpha = .3, cex = .2
  ) +
  xlab( "Mittelwerte" )  + ylab( "Verhältnisse" )
```

Wenn die Mittelwerte erst nach der Logarithmierung berechnet werden, verschiebt sich der Plot insbesondere für niedrig exprimierte Gene: Der Mittelwert entspricht dann dem **geometrischen Mittel** der ursprünglichen Expressionsstärken. Das geometrische Mittel ist gegenüber dem arithmetischen Mittel besser geeignet, um logarithmische Unterschiede in der Genexpression darzustellen, da es relative Veränderungen korrekt abbildet.

Mathematisch sind die zwei Ausdrücke - `log10( (cpmA + 0.1) / (cpmB + 0.1) )` und `log10(cpmA + 0.1) - log10(cpmB + 0.1)`- äquivalent. Da in der Praxis jedoch meist direkt mit lcpm-Werten gearbeitet wird, ist der zweite Ausdruck gebräuchlicher und einfacher zu verwenden.

### 1d

Finden Sie die Namen der 10 Gene, bei denen das Expressionsverhältnis von P63 zu P1 am größten oder am kleinsten ist.

```{r}
cpm_wide %>%
  select(gene_id, Liver_P63_1, Liver_P3_1) %>%
  mutate(prop_cpm = (Liver_P63_1 + .1) / (Liver_P3_1 + .1)) %>%
  arrange(desc(prop_cpm)) %>%
  head(10) 
# top10 differentially expressed genes with stronger expression in Liver_P_63_1 
```

```{r}
cpm_wide %>%
  select(gene_id, Liver_P63_1, Liver_P3_1) %>%
  mutate(prop_cpm = (Liver_P63_1 + .1) / (Liver_P3_1 + .1)) %>%
  arrange(prop_cpm) %>%
  head(10)
# top10 differentially expressed genes with stronger expression in Liver_P_3_1
```

### 1e

Vergleichen Sie die Plots aus (a) und (b). Können Sie erkennen, dass der Plot aus (b) derselbe wie in (a) ist, aber um 45° gedreht?

Ich habe alle Daten als Data Frames behandelt und die Plots mit *ggplot* erstellt. Alternativ könnten die Daten auch als Matrizen gespeichert werden, sodass man die Plots direkt mit Base R erzeugen kann. Wenn es Ihnen lieber ist, hier ist der Code (mit Shift+Ctrl+C dekommentieren):

```{r}
# # pre-processing
# 
# mouse_counts %>% column_to_rownames( "gene_id" ) %>% as.matrix() -> count_matrix
# 
# count_matrix[ 1:5, 1:5 ]
# 
# t( t(count_matrix) / colSums(count_matrix) ) * 1e6 -> cpm_matrix
# 
# cpm_matrix[1:5, 1:5]
# 
# # 1a
# 
# plot(
#   log10( cpm_matrix + 0.1) [ , "Liver_P63_1"], 
#   log10( cpm_matrix + 0.1) [ , "Liver_P3_1"], 
#   cex = .2, col = alpha("black", .3), 
#   xlab = "Liver_P63_1", ylab = "Liver_P3_1"
# )
# abline( 0, 1, col = "orange")
# 
# # 1b
# 
# plot(
#   log10( ( (cpm_matrix + .1) [ , "Liver_P63_1"] + (cpm_matrix + .1) [ , "Liver_P3_1"] ) / 2 ),
#   log10( (cpm_matrix + .1) [ , "Liver_P63_1"] / (cpm_matrix + .1) [ , "Liver_P3_1"] ),
#   cex = .2, col = alpha("black", .3),
#   xlab = "Mittelwerte", ylab = "Verhältnisse"
# )
# 
# # 1c
# 
# plot(
#   ( log10( (cpm_matrix + .1) [ , "Liver_P63_1"] ) + log10( (cpm_matrix + .1) [ , "Liver_P3_1"] ) ) / 2,
#   log10( (cpm_matrix + .1) [ , "Liver_P63_1"] / (cpm_matrix + .1) [ , "Liver_P3_1"] ), 
#   cex = .2, col = alpha("black", .3), 
#   xlab = "Mittelwerte", ylab = "Verhältnisse"
# )
# 
# # 1d
# 
# ( (cpm_matrix + .1) [ , "Liver_P63_1"] / (cpm_matrix + .1) [ , "Liver_P3_1"] ) %>%
#   sort( decreasing = TRUE ) %>%
#   head(10) # top10 differentially expressed genes with stronger expression in Liver_P_63
# 
# ( (cpm_matrix + .1) [ , "Liver_P63_1"] / (cpm_matrix + .1) [ , "Liver_P3_1"] ) %>%
#   sort( decreasing = FALSE ) %>%
#   head(10) # top10 differentially expressed genes with stronger expression in Liver_P_3
```

## Aufgabe 2: Vergleich zweier Gruppen

### 2a

Berechnen Sie die Mittelwerte der Expressionsstärken der 4 Proben von P3-Lebern und der 4 Proben von P63-Lebern. Denken Sie daran, erst die Logarithmen zu nehmen und dann erst den Mittelwert.

Erstellen Sie eine Tabelle, die für jedes Gen angibt: die Ensembl-ID und den Namen (HGNC-Symbol) des Gens, mittlere log-Expression in P3-Leber und in P63-Leber, Gesamt-Mittelwert (P3 und P63 zusammen), und logarithmiertes Verhältnis der P3- und P63-Expression.

Benutzen Sie die Tabelle, um einen Plot zu erstellen, der so ähnlich wie der Plot aus Aufgabe 1b aussieht.

```{r}
read_tsv( "Ensembl_102_GRCm38.p6_Gene_names.tsv" ) -> gene_names

cpm_long %>%
  left_join( sample_table ) %>%
  group_by( organ, timepoint, gene_id ) %>%
  summarise( mean_cpm = mean(cpm) ) %>%
  mutate( mean_lcpm = log10( mean_cpm + 0.1 ), .keep = "unused") %>%
  unite( col = "organ_timepoint", organ, timepoint, sep = "_" ) %>%
  pivot_wider( names_from = organ_timepoint, values_from = mean_lcpm ) -> lcpm_wide

head(lcpm_wide)
```

```{r}
lcpm_wide %>%
  select(gene_id, Liver_P3, Liver_P63) %>%
  mutate(
    avg_lcpm = (Liver_P3 + Liver_P63)/2,
    prop_lcpm = (Liver_P63 + 0.1) - (Liver_P3 + 0.1) 
  ) %>%
  left_join(gene_names) -> avg_livers

head(avg_livers)
```

```{r}
avg_livers %>%  
  ggplot() +
  geom_point(
    aes( x = avg_lcpm, y = prop_lcpm ), 
    alpha = .3, cex = .2
  ) +
  xlab( "Mittelwerte" )  + ylab( "Verhältnisse" )
```

### 2b

Suchen Sie wieder die jeweils 10 Gene mit dem größten und kleinsten logarithmischen Expressionsverhältnis heraus. Dies sind die Gene, die im Plot aus (a) ganz oben und ganz unten erscheinen.

```{r}
avg_livers %>%
  arrange(desc(Liver_P63-Liver_P3)) %>%
  head(10) -> top10_p63 # top 10 genes with expresion higher in P63

top10_p63
```

```{r}
avg_livers %>%
  arrange(Liver_P63 - Liver_P3) %>%
  head(10) -> top10_p3 # top 10 genes with expresion higher in P3

top10_p3
```

Finden Sie auch 10 Gene, die im Plot von (a) in etwa am oberen Rand der dichteren Punktwolke in der Mitte des Plots liegen.

```{r}
avg_livers %>%
  filter( 
    avg_lcpm > 1 & avg_lcpm < 2 ,
    prop_lcpm > 0.6 & prop_lcpm < 0.7
    ) %>%
  arrange(desc(prop_lcpm)) %>%
  head(10) -> mid10 

mid10
```

### 2c

Erstellen Sie für einige der Gene aus (b) jeweils einen Beeswarm-Plot, der die Expressionswerte der einzelnen Proben für das Gen darstellt

```{r}
cpm_long %>%
  mutate( lcpm = log10( cpm + 0.1 ) ) %>%
  left_join( sample_table ) %>%
  left_join ( gene_names ) -> lcpm_long
```

```{r}
lcpm_long %>%
  filter(
    organ == "Liver",
    timepoint %in% c("P3", "P63"), 
    gene_name %in% pull(top10_p63, gene_name)
    ) %>%
  ggplot() +
  ggbeeswarm::geom_beeswarm( aes ( x = timepoint, y = lcpm ) ) +
  facet_wrap( ~ gene_name ) 
```

```{r}
lcpm_long %>%
  filter(
    organ == "Liver",
    timepoint %in% c("P3", "P63"), 
    gene_name %in% pull(top10_p3, gene_name)
    ) %>%
  ggplot() +
  ggbeeswarm::geom_beeswarm( aes ( x = timepoint, y = lcpm ) ) +
  facet_wrap( ~ gene_name ) 
```

```{r}
lcpm_long %>%
  filter(
    organ == "Liver",
    timepoint %in% c("P3", "P63"), 
    gene_name %in% pull(mid10, gene_name)
    ) %>%
  ggplot() +
  ggbeeswarm::geom_beeswarm( aes ( x = timepoint, y = lcpm ) ) +
  facet_wrap( ~ gene_name )
```

### 2d

Vergleichen Sie für einige der Gene aus (b) die je 4 Werte aus den beiden Gruppen (P3 und P63) mit einem t-Test.

```{r}
lcpm_long %>%
  filter(
    organ == "Liver", 
    timepoint %in% c("P3", "P63"), 
    gene_name %in% pull(top10_p63, gene_name)
  ) %>%
  group_by( gene_name ) %>%
  summarize(
    broom::tidy( t.test (lcpm ~ timepoint) )
  )
```

```{r}
lcpm_long %>%
  filter(
    organ == "Liver", 
    timepoint %in% c("P3", "P63"), 
    gene_name %in% pull(top10_p3, gene_name)
  ) %>%
  group_by( gene_name ) %>%
  summarize(
    broom::tidy( t.test (lcpm ~ timepoint) )
  )
```

## Aufgabe 3: t-Tests zur Gen-Expression

```{r}
# install.packages( "BiocManager" )
# Biocmanager::install( "genefilter" )
```

```{r}
livers <- cpm_long %>%
  left_join( sample_table ) %>%
  filter( organ == "Liver" & timepoint %in% c("P3", "P63") ) %>%
  mutate( lcpm = log10(cpm + 0.1) ) %>%
  select( gene_id, sample, lcpm ) %>%
  pivot_wider( names_from = sample, values_from = lcpm ) 

head(livers)
```

```{r}
m <- livers %>%
  column_to_rownames( "gene_id" ) %>% 
  as.matrix() 

m[1:5, 1:8]
```

```{r}
f <- factor( rep( c( "P3", "P63" ), each = 4 ) )
genefilter::rowttests( m, f ) -> res_livers
head(res_livers)
```

```{r}
res_livers %>%
  mutate( p.adj = p.adjust( p.value, method = "BH" ) ) -> res_adj

res_adj %>%
  ggplot() +
  geom_point( aes( x = dm, y = -log(p.adj), col = (p.adj < 0.1) ), size = 0.2, alpha = 0.3 ) +
  scale_color_manual( values = c( "FALSE" = "black", "TRUE" = "red" ) )
```
